#!/usr/bin/env python
#
# Copyright (C) STMicroelectronics Ltd. 2012
#
# This file is part of ATOS.
#
# ATOS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License v2.0
# as published by the Free Software Foundation
#
# ATOS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# v2.0 along with ATOS. If not, see <http://www.gnu.org/licenses/>.
#
#
# Usage: get usage with atos-acf-oprofile -h
#

VERSION="@VERSION@"

import sys, os, re, tempfile, commands


def find_binary_in_path(image_name, bin_path):
    for path in bin_path.split(':'):
        if os.path.isfile(os.path.join(path,image_name)):
            return os.path.join(path,image_name)
    return None

def check_format(oprof_output):
    oprofile_format = None
    for line in open(oprof_output):
        if re.match(r'vma +samples +% +image[ _]name +symbol[ _]name *', line):
            # vma samples  %   image name  symbol name
            # 04004c0 1424923 85.6763  a.out main
            oprofile_format = 1
            break
        elif re.match(r'vma +samples +% +linenr[ _]info +image[ _]name +symbol[ _]name *', line):
            # vma samples  %      linenr info          image name  symbol name
            # 0c144 20626 20.3311 (no localization information)  a.out main
            oprofile_format = 2
            break
        elif re.match(r'vma +samples +% +linenr[ _]info +image[ _]name +app[ _]name +symbol[ _]name *', line):
            # vma samples  %      linenr info          image name  app name   symbol name
            # 0x19e 22583 0.0312813 (no location information) libxx.so libxx.so func1
            oprofile_format = 3
            break
    return oprofile_format

def parse_binary_list(oprof_output, oprofile_format, binary, bin_path):
    binary_list = []
    for line in open(oprof_output):
        if not re.match(r'^[0-9a-fA-F]+ +\d+ +[\d\.]+ +.*', line):
            continue
        # we're on a symbol line:
        words = line.split()
        if oprofile_format == 1:
            image_name = words[3]
        elif oprofile_format == 2 or oprofile_format == 3:
            # handle (no-location-information) case
            #   0000000 156636 9.4180 (no location information) no-vmlinux
            image_name = (words[3] == '(no') and words[6] or words[4]
        # detect if we are in an interesting region of the profile file
        if image_name != 'anon':
            if os.path.basename(image_name) == os.path.basename(binary):
                # Handle -e <binary> option
                if not (image_name, binary) in binary_list:
                    binary_list += [(image_name, binary)]
            else:
                ret_path = find_binary_in_path(image_name, bin_path)
                if ret_path and not (image_name, ret_path) in binary_list:
                    binary_list += [(image_name, ret_path)]
    return binary_list

def parse_profile(oprof_output, oprofile_format, binary_list):
    # read couples of (address, sample_count) from oprofile output
    samples = {}
    for line in open(oprof_output):
        if not re.match(r'^[0-9a-fA-F]+ +\d+ +[\d\.]+ +.*', line):
            continue
        # we're on a symbol line:
        words = line.split()
        # handle (no-location-information) case
        #   0000000 156636 9.4180 (no location information) no-vmlinux
        if words[3] == '(no':
            words[3] = ' '.join(words[3:6])
            del words[4:6]
        image_name = (oprofile_format == 1) and words[3] or words[4]
        # detect if we are in an interesting region of the profile file
        for (bin, path) in binary_list:
            in_binary_region = (os.path.basename(image_name) == os.path.basename(bin))
            if not in_binary_region: continue
            vma, samps, percent = words[0:3]
            linenr, app_name = ' ', ' '
            if oprofile_format == 3:
                app_name = words.pop(5)
            if oprofile_format in [2, 3]:
                linenr = words.pop(3)
            if oprofile_format in [1, 2, 3]:
                sym = words[4]
            # merge multiple entries for same image_name/sym
            sym_found = False
            sym = sym.split('.')[0]
            if image_name in samples.keys():
                for (vma_c, samps_c, percent_c, linenr_c, image_name_c,app_name_c, sym_c
                     ) in samples[image_name]:
                    if sym_c != sym: continue
                    # accumulate samples and update list
                    samples[image_name].remove(
                        (vma_c, samps_c, percent_c, linenr_c, image_name_c, app_name_c, sym_c))
                    samples[image_name].insert(0,
                        (vma, str(int(samps) + int(samps_c)), str(
                                float(percent) + float(percent_c)), linenr, image_name, app_name, sym))
                    sym_found = True
                    break
            if not sym_found:
                samples.setdefault(image_name, []).append(
                    (vma, samps, percent, linenr, image_name, app_name, sym))
            break
    return samples

def compiler_opt_to_attribute(opt):
    if opt.startswith('-O'):
        # handles -Ox options
        csv_opt = 'optimize,' + opt[2:]
    elif opt.startswith('-f'):
        # handle -fx options
        csv_opt = 'optimize,' + opt[2:]
    else:
        # handle direct attributes
        csv_opt = opt + ','
    return csv_opt

def create_debug_info_list(binary_file, addr_file_path, addr2line):
    dbg_info = {}
    status, res = commands.getstatusoutput(
        addr2line + ' --functions --exe ' + binary_file + ' @' + addr_file_path)
    addr_file = open(addr_file_path)
    odd = False
    for line in res.split('\n'):
        # addr2line --functions returns 2 lines for each address:
        # <function_name>\n<file>:<line>
        # If address doesn't match debug information, it returns '??' for
        # <function_name> and<file>, 0 for <line>
        if not odd:
            # We are on a <function_name> line
            current_addr = addr_file.readline().rstrip('\n')
            current_func = line
            odd = True
        else:
            # We are on a <file>:<line> line
            odd = False
            if not re.match('^.*:\d+$', line):
                print 'Warning: malformed debug information (address= ' + current-addr + '): discarding ' + line
                continue
            words = line.split(':')
            dbg_info[current_addr] = (current_func, words[0], words[1])
    addr_file.close()
    return dbg_info

def get_file(debug_info, vma):
    # returns the basename of the file
    (debug_func, debug_file, debug_line) = debug_info[vma]
    if debug_func == '??' or debug_file == '??':
        # Debug information was not found for this address
        source_file = None
    else:
        # addr2line sometimes returns the demangled function name while not requested,
        # adding a ~ leading character.
        # Only check if debug_func is part of funcname, first removing extra ~
        ### The check fails for functions inlined in .h files for which
        ### readelf and addr2line report a different function for a given address...
        # if not debug_func.lstrip('~') in sym:
        #     print 'Warning: Incorrect debug information'
        source_file = os.path.basename(debug_file)
    return source_file

def print_acf_info(samples, binary_list,
                   acf_hot_treshold, acf_hot_opts, acf_cold_treshold, acf_cold_opts, addr2line):
    hot_opts_for_csv = []
    if acf_hot_treshold and acf_hot_opts:
        # Parse hot options
        hot_opts = acf_hot_opts.split()
        hot_opts_for_csv = map(compiler_opt_to_attribute, hot_opts)

    cold_opts_for_csv = []
    if acf_cold_treshold and acf_cold_opts:
        # Parse cold options
        cold_opts = acf_cold_opts.split()
        cold_opts_for_csv = map(compiler_opt_to_attribute, cold_opts)

    for image_name in samples.keys():

        total_count = sum(map(lambda x: int(x[1]), samples[image_name]))

        # Get debug information for functions in current binary if available
        # Source file information is used to avoid ambiguities between functions
        # with same name in different binaries/libraries inside the GNU acf-plugin
        for (bin, path) in binary_list:
            if bin != image_name: continue
            # Store all relevant function addresses in a temporary file
            # to get debug information
            address_file = tempfile.NamedTemporaryFile(delete=False)
            ### TODO: Remove duplicate addresses
            address_file.write('\n'.join(map(lambda x: x[0], samples[image_name])))
            address_file.close()
            debug_info = create_debug_info_list(path, address_file.name, addr2line)
            os.remove(address_file.name)
            break

        # Generate hot csv lines
        current_hot_count = 0
        if acf_hot_treshold:
            for (vma, samps, percent, linenr, image_name, app_name, sym) in samples[image_name]:
                current_hot_count += int(samps)
                if current_hot_count < total_count * (float(acf_hot_treshold) / 100.0):
                    source_file = get_file(debug_info, vma)
                    for opt in hot_opts_for_csv:
                        print sym + ',' + opt + ((',' + source_file) if source_file else '')
                else: break

        # Generate cold csv lines
        current_cold_count = 0
        if acf_cold_treshold:
            for (vma, samps, percent, linenr, image_name, app_name, sym) in samples[image_name]:
                current_cold_count += int(samps)
                if current_cold_count < (total_count * ((100.0 - float(acf_cold_treshold)) / 100.0)):
                    last_cold_count = current_cold_count
                else:
                    source_file = get_file(debug_info, vma)
                    for opt in cold_opts_for_csv:
                        print sym + ',' + opt + ((',' + source_file) if source_file else '')

def print_fbf_info(samples, binary_list, fbf_map, readelf):


    fct_map, obj_list = {}, set()

    for line in open(fbf_map):
        words = line.split()
        if len(words) < 2: continue
        obj, fct = words[:2]
        fct_map.setdefault(fct, []).append(obj)
        obj_list.add(obj)

    for image_name in samples.keys():
        obj_samples = dict(map(lambda x: (x, 0), obj_list))
        for (_, samps, _, _, _, _, sym) in samples[image_name]:
            objs = fct_map.get(sym, None)
            if not objs: continue
            for obj in objs: obj_samples[obj] += int(samps)

        total_count = sum(obj_samples.values())
        obj_samples = sorted(obj_samples.items(), key=lambda x: x[1])
        for (obj, count) in reversed(obj_samples):
            obj_part = float(count) / total_count * 100.0
            print '%s %d %5.1f' % (obj, float(count), obj_part)


if __name__ == '__main__':

    import optparse

    parser = optparse.OptionParser(
        description='oprofile parser for acf plugin',
        version="%prog version " + VERSION)
    # general options
    parser.add_option('--with-addr2line', dest='addr2line',
              action='store', type='string', default='addr2line',
              help='set the path to addr2line')
    parser.add_option('--with-readelf', dest='readelf',
              action='store', type='string', default='readelf',
              help='set the path to readelf')
    parser.add_option('--debug', dest='debug',
              action='store_true', default=False,
              help='enable debug mode')
    # profile options
    parser.add_option('-i', '--infile', dest='oprof_output',
              action='store', type='string', default='oprof.out',
              help='set the sample file name (default: oprof.out)')
    parser.add_option('-e', '--execfile', dest='binary',
              action='store', type='string', default='',
              help='set the binary file name (default: "")')
    parser.add_option('-p', '--binary_path', dest='bin_path',
              action='store', type='string', default='',
              help='colon separated path to find binaries not specified with --execfile option')
    # acf options
    parser.add_option('--acf-hot-th', dest='acf_hot_treshold',
              action='store', type='int', default=50,
              help='set the hot function samples % treshold for acf plugin (default 50)')
    parser.add_option('--acf-cold-th', dest='acf_cold_treshold',
              action='store', type='int', default=30,
              help='set the hot function samples treshold for acf plugin')
    parser.add_option('--acf-hot-opts', dest='acf_hot_opts',
              action='store', type='string', default="-O3",
              help='set the hot function optimizations for acf plugin')
    parser.add_option('--acf-cold-opts', dest='acf_cold_opts',
              action='store', type='string', default="-Os cold noinline",
              help='set the hot function samples optimizations for acf plugin')
    # file-by-file options
    parser.add_option('--fbf-list', dest='fbf_list',
              action='store_true', default=False,
              help='get compilation units sorted by samples %')
    parser.add_option('--fbf-map', dest='fbf_map',
              action='store', type='string', default='map.out',
              help='set the function-object map file name')

    (opts, args) = parser.parse_args()

    if opts.binary and not os.path.isfile(opts.binary):
        parser.error('binary file not found: "%s"' % opts.binary)

    if not os.path.isfile(opts.oprof_output):
        parser.error('profile file not found: "%s"' % opts.oprof_output)

    oprofile_format = check_format(opts.oprof_output)

    if not oprofile_format:
        print>>sys.stderr, '%s: error: oprofile output format not supported' %(
            os.path.basename(sys.argv[0]))
        sys.exit(1)

    binary_list = parse_binary_list(
        opts.oprof_output, oprofile_format, opts.binary, opts.bin_path)

    samples = parse_profile(opts.oprof_output, oprofile_format, binary_list)

    # file partitioning mode
    if opts.fbf_list:
        if not opts.fbf_map: parser.error(
            'func-to-object map file must be given using option --fbf-map')
        print_fbf_info(samples, binary_list, opts.fbf_map, opts.readelf)
        sys.exit(0)

    # classic acf mode
    print_acf_info(samples, binary_list,
                   opts.acf_hot_treshold, opts.acf_hot_opts,
                   opts.acf_cold_treshold, opts.acf_cold_opts,
                   opts.addr2line)
