#!/usr/bin/env python
#
# Copyright (C) STMicroelectronics Ltd. 2012
#
# This file is part of ATOS.
#
# ATOS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License v2.0
# as published by the Free Software Foundation
#
# ATOS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# v2.0 along with ATOS. If not, see <http://www.gnu.org/licenses/>.
#
# Usage: get usage with atos-deps -h
#

VERSION="@VERSION@"

import re
import os
import sys
import getopt
from pygraph.classes.digraph import digraph

VERBOSE=0

class DependencyGraph:
    """ A class implementing a dependency graph. """
    def __init__(self, dg = None):
        """ Constrcutor. Optionally pass a pygraph.classes.digraph as argument.  """
        global VERBOSE
        self.dg = dg
        if self.dg == None:
            self.dg = digraph()
        self.verbose = VERBOSE

    def add_node(self, node, attrs = None):
        """ Add a node. """
        if self.verbose:
            print "ADD_NODE: " + node
        self.dg.add_node(node, attrs = attrs)

    def del_node(self, node):
        """ Delete a node and related edges. """
        self.dg.del_node(node)


    def has_node(self, node):
        """ Returns whether the graph contains the node. """
        return self.dg.has_node(node)

    def add_edge(self, src, dst):
        """ Add an edge. """
        if self.verbose:
            print "ADD_EDGE: " + src + " " + dst
        self.dg.add_edge((src, dst))

    def del_edge(self, src, dst):
        """ Delete an edge. """
        self.dg.del_edge((src, dst))

    def nodes(self):
        """ Returns the list of nodes. """
        return self.dg.nodes()

    def edges(self):
        """ Returns the list of edges. """
        return self.dg.edges()

    def graph(self):
        """ Get the graph as a nodes, edges map. """
        return { 'nodes': self.nodes(), 'edges': self.edges() }

    def node_attributes(self):
        """ Get the node attributes. """
        return self.dg.node_attr

    def get_makedep(self):
        """ Get a makefile like output. """
        mk = ""
        for node in self.dg.nodes():
            mk = mk + node + ": " + " ".join(self.dg.neighbors(node)) + "\n"
        return mk

    def get_targets(self):
        """ Get the list of targets. """
        targets = []
        for node in self.dg.neighbors("ROOT"):
            for attr,value in self.dg.node_attr[node]:
                if attr == "target":
                    targets.append(value)
        return targets

    def get_lto_opts(self):
        """ Get the list of options that should be passed to linker in case of LTO build. """
        def is_lto_opt(arg): return (arg.startswith('-m') or arg.startswith('-f'))
        optflags = []
        for node in self.dg.nodes():
            for attr, value in self.dg.node_attr[node]:
                if attr != 'dependency' or value['kind'] != 'CC': continue
                optflags += [x for x in value['command']['args'] if is_lto_opt(x) and x not in optflags]
        return optflags

    def output_makefile(self,makefile):
        """ Get a parallelizable makefile for rebuilding the target. """
        mkfile = open(makefile,"w")
        mkfile.write("#!/usr/bin/make -f\n")
        mkfile.write("SHELL=/bin/sh\n")
        mkfile.write("FORCE=FORCE\n")
        mkfile.write("QUIET=@\n")
        mkfile.write(".PHONY: ROOT all\n")
        mkfile.write(".SUFFIXES:\n")
        mkfile.write("all: ROOT\n")
        mkfile.write("FORCE:\n")
        mkfile.write("ifeq ($(LTO),1)\n")
        mkfile.write("LTOFLAGS=%s\n" % (' '.join(self.get_lto_opts())))
        mkfile.write("endif\n")
        for node in self.dg.nodes():
            target = node
            recipe = None
            for attr,value in self.dg.node_attr[node]:
                if attr == "target":
                    target = value
                if attr == "dependency":
                    append=""
                    if value['kind'] == "CC":
                        append=" $(ACFLAGS)"
                    if value['kind'] == "CCLD":
                        append=" $(LTOFLAGS) $(ACFLAGS) $(ALDFLAGS)"
                    # TODO: handle quotes in command
                    recipe = "$(QUIET)cd " + value['command']['cwd'] + " && " + " ".join(value['command']['args']) + append
                    recipe = re.sub(r'(["\'])', r'\\\1', recipe)
            deps = []
            for dep in self.dg.neighbors(node):
                for attr,value in self.dg.node_attr[dep]:
                    if attr == "target":
                        deps.append(value)
            mkfile.write(target + ": $(FORCE) " + " ".join(deps) + "\n")
            if recipe == None:
                mkfile.write("\n")
            else:
                mkfile.write("\t" + recipe + "\n")
        mkfile.close

class DependencyGraphBuilder:
    """ Class for building dependency list. """
    def __init__(self, deplist, targets):
        """ Constructor. Takes a DependencyList as argument and a list of output_file targets. """
        self.graph = DependencyGraph()
        self.deplist = deplist
        self.targets = targets

    def target_match(self, target, output):
        """ Check if output matches a target. Assume that target is a suffix of output. """
        m = re.search(os.path.normpath(target) + "$", output)
        return m != None

    def build_graph(self):
        """ Builds Add a dependency consisting of a node and input/output lists. """
        self.graph.add_node("ROOT")
        if self.targets == "all" or self.targets == "last":
            targets = []
            for i in range(len(self.deplist)):
                dependency = self.deplist[len(self.deplist)-i-1]
                if len(dependency['outputs']) != 1:
                    continue
                if dependency['kind'] == "CCLD" and len(dependency['outputs']) == 1:
                    targets.append(dependency['outputs'][0])
                    if self.targets == "last":
                        break
        else:
            targets = self.targets
        unmatched_targets = targets
        available_inputs = set()
        referenced_outputs = set()

        for i in range(len(self.deplist)):
            dependency = self.deplist[len(self.deplist)-i-1]
            if len(dependency['outputs']) != 1:
                continue
            output = dependency['outputs'][0]
            found = False
            for target in unmatched_targets:
                if self.target_match(target, output):
                    if output in referenced_outputs:
                        raise Exception("Output file referenced several times: " + output)
                    unmatched_targets.remove(target)
                    found = True
                    referenced_outputs.add(output)
                    self.graph.add_node(output, attrs = [('target', output), ('dependency', dependency)])
                    self.graph.add_edge("ROOT", output)
                    for inp in dependency['inputs']:
                        available_inputs.add(inp)
                        if not self.graph.has_node(inp):
                            self.graph.add_node(inp, attrs = [('target', inp)])
                        self.graph.add_edge(output, inp)
            if not found:
                if output in available_inputs:
                    if output in referenced_outputs:
                        raise Exception("Output file referenced several times: " + output)
                    referenced_outputs.add(output)
                    available_inputs.remove(output)
                    if not self.graph.has_node(output):
                        raise Exception("Expected to have seen output in dependencies: " + output)
                    self.graph.node_attributes()[output] = [('target', output), ('dependency', dependency)]
                    for inp in dependency['inputs']:
                        available_inputs.add(inp)
                        if not self.graph.has_node(inp):
                            self.graph.add_node(inp, attrs = [('target', inp)])
                        self.graph.add_edge(output, inp)
        # Check for unmatched targets
        if len(unmatched_targets) > 0:
            for target in unmatched_targets:
                print >> sys.stderr, "warning: unmatched target executable, will not be optimized: " + target
        # Prune nodes with no recipe (remove speculated inputs)
        for node in self.graph.nodes():
            if node == "ROOT":
                continue
            real = False
            for attr,value in self.graph.node_attributes()[node]:
                if attr == "dependency":
                    real = True
            if not real:
                self.graph.del_node(node)
        
    def get_graph(self):
        """ Returns the dependency graph. """
        return self.graph

class DependencyListBuilder:
    """ Class for building dependency list. """
    def __init__(self):
        """ Constructor. """
        self.deps = []

    def add_dependency(self, command, kind, inputs, outputs):
        """ Add a dependency consisting of a node and input/output lists. """
        dependency = { 'command': command, 'kind': kind, 'inputs': inputs, 'outputs': outputs }
        self.deps.append(dependency)

    def get_dependencies(self):
        """ Returns the dependency list. """
        return self.deps

class SimpleCmdInterpreter:
    """ Returns information on a command line for compilations tools. """
    def __init__(self):
        """ Constructor. """

    def select_interpreter(self, command):
        """ Returns a suitable interpreter for the given command. """
        basename = os.path.basename(command['args'][0])
        # TODO: put these regexps in a configuration file
        m = re.search("(gcc|g\+\+|cc|c\+\+)$", basename)
        if m != None and m.group(1) != None:
            return SimpleCCInterpreter(command)
        m = re.search("(ar)$", basename)
        if m != None and m.group(1) != None:
            return SimpleARInterpreter(command)
        raise Exception("unrecognized command: " + basename)

    def get_kind(self, command):
        """ Get command kind from command line args. """
        return self.select_interpreter(command).get_kind(command)
        
    def get_input_files(self, command):
        """ Get input files from command line args. """
        return self.select_interpreter(command).get_input_files(command)

    def get_output_files(self, command):
        """ Get output files from command line args. """
        return self.select_interpreter(command).get_output_files(command)

class SimpleCCInterpreter:
    """ Returns information on a command line for a CC compiler driver.
    There are a number of limitations:
    - only well known extensions are searched for input files
    - output file is matched only in case of -o option, no stdout support
    """
    def __init__(self, command):
        """ Constructor. """
        self.command = command
        self.kind = None
        self.input_files = None
        self.output_files = None

    def get_kind(self, command):
        """ Returns the command kind. """
        if self.kind != None:
            return self.kind
        args = command['args']
        kind = "CCLD"
        for i in range(len(args[1:])):
            m = re.search("^(-c)$", args[i+1])
            if m != None:
                kind = "CC"
        return kind

    def get_input_files(self, command):
        """ Get input files from CC command line args (C/C++ sources or object files). """
        if self.input_files != None:
            return self.input_files
        inputs = []
        args = command['args']
        lpath = []
        i = 1
        while i < len(args):
            m = re.search("^-o(.*)$", args[i])
            if m != None:
                if m.group(1) == "":
                    i = i + 2
                else:
                    i = i + 1
                continue
            m = re.search("\\.(c|cc|cxx|cpp|c\+\+|C|i|ii|o|a)$", args[i])
            if m != None:
                inputs.append(os.path.normpath(os.path.join(command['cwd'], args[i])))
                i = i + 1
                continue
            m = re.search("^-L(.*)$", args[i])
            if m != None:
                path = m.group(1)
                if path == "":
                    if i+1 < len(args):
                        path = args[i+1]
                    i = i + 2
                else:
                    i = i + 1
                if path != "":
                    lpath.append(os.path.normpath(os.path.join(command['cwd'], path)))
                continue
            m = re.search("^-l(.*)$", args[i])
            if m != None:
                lib = m.group(1)
                if lib == "":
                    if i+1 < len(args):
                        lib = args[i+1]
                    i = i + 2
                else:
                    i = i + 1
                if lib != "":
                    for path in lpath:
                        inputs.append(os.path.join(path, "lib" + lib + ".a"))
                continue
            i = i + 1

        return inputs

    def get_output_files(self, command):
        """ Get output files from CC command line args. """
        if self.output_files != None:
            return self.output_files
        args = command['args']
        outputs = []
        i = 1
        while i < len(args):
            m = re.search("^-o(.*)$", args[i])
            if m != None:
                output = m.group(1)
                if output == "":
                    if i+1 < len(args):
                        output = args[i+1]
                    i = i + 2
                else:
                    i = i + 1
                outputs = [ os.path.normpath(os.path.join(command['cwd'], output)) ]
                continue
            i = i + 1

        if len(outputs) == 0 and len(self.get_input_files(command)) > 0:
            if self.get_kind(command) == "CC":
                outputs = []
                for inp in self.get_input_files(command):
                    outputs.append(os.path.normpath(os.path.join(command['cwd'], re.sub("\\.[^.]+$", ".o", os.path.basename(inp)))))
            elif self.get_kind(command) == "CCLD":
                outputs = [ os.path.normpath(os.path.join(command['cwd'], "a.out")) ]
            else:
                raise Exception("Can't determine output from input files in command: " + str(command))
        return outputs


class SimpleARInterpreter:
    """ Returns information on a command line for a AR archiver. 
    There qre q number of limitations:
    - only .o files are searched for input
    - only 'ar ...r... input_files...' form is recognized 
    """
    def __init__(self, command):
        """ Constructor. """
        self.command = command

    def get_kind(self, command):
        """ Returns the command kind. """
        return "AR"

    def get_input_files(self, command):
        """ Get input files from AR command line (object files only). """
        inputs = []
        args = command['args']
        for i in range(len(args[1:])):
            m = re.search("\\.(o)$", args[i+1])
            if m != None and m.group(1) != None and i >= 2:
                    inputs.append(os.path.normpath(os.path.join(command['cwd'], args[i+1])))
        return inputs

    def get_output_files(self, command):
        """ Get output file from AR command line args. """
        args = command['args']
        outputs = []
        update = False
        for i in range(len(args[1:])):
            if i == 0:
                m = re.search("r", args[i+1])
                if m != None:
                    update = True
            elif i == 1 and update:
                outputs = [ os.path.normpath(os.path.join(command['cwd'], args[i+1])) ]
            else:
                break
        return outputs

class CommandDependencyListFactory:
    """ Creates a build dependency from a command parser and a command interpreter. """
    def __init__(self, parser, interpreter):
        """ Constructor. """
        self.deps = DependencyListBuilder()
        self.parser = parser
        self.interpreter = interpreter

    def get_dependencies(self):
        """ Returns the build dependencies. """
        return self.deps.get_dependencies()
    
    def build_dependencies(self):
        """ Compute dependencies.  """
        self.parser.parse()
        commands = self.parser.get_commands()
        for command in commands:
            input_files = self.interpreter.get_input_files(command)
            output_files = self.interpreter.get_output_files(command)
            kind = self.interpreter.get_kind(command)
            self.deps.add_dependency(command, kind, input_files, output_files)
                
class CCDEPSParser:
    """ Parses the output of a cc_deps addon file. """
    def __init__(self, input_file):
        """ Constructor, takes the input_file as argument. """
        self.input_file = input_file
        self.commands = []
        
    def parse(self):
        """ Parses the input_file. """
        for line in self.input_file:
            self.commands.append(self.parse_line(line))

    def parse_line(self, line):
        """ Parses a single input_file. """
        try:
            m = re.search("^CC_DEPS: \"([^\"]*)\": (.*): : \"([^\"]*)\"$", line)
            arg0 = m.group(1)
            args = m.group(2)
            cwd = m.group(3)
            len(arg0)
            len(args)
            len(cwd)
        except Exception:
            raise Exception("unexpected cc_deps command line: " + line)
        arg_list = args.split(", ")
        command = {'arg0': arg0, 'args': [], 'cwd': cwd}
        for arg in arg_list:
            try:
                m = re.search("^\"(.*)\"$", arg)
                opt = m.group(1)
                len(opt)
            except Exception:
                raise Exception("unexpected argument in command: " + arg)
            command['args'].append(opt)
        if len(command['args']) == 0:
            raise Exception("unexpected empty command: " + str(arg_list))
        return command

    def get_commands(self):
        """ Returns the constructed command list.  """
        return self.commands

configuration_path = "./atos-configurations"

def usage():
    default_input_name = os.path.join(configuration_path, "build.audit")
    default_output_name = os.path.join(configuration_path, "build.mk")
    print "Usage: " + os.path.basename(sys.argv[0]) + " [options] [targets...]"
    print
    print "Compute reproducible build actions from a previously audited build"
    print "The arguments targets... is the list of executable to consider for optimization"
    print
    print "Options:"
    print "  -C <path> : configuration path [default: " + configuration_path + "]"
    print "  -i <build_audit>: input build audit as generated by atos-audit [default: " + default_input_name + "]"
    print "  -o <build_description>: output build description suitable for atos-opt [default: " + default_output_name + "]"
    print "  -l : use last build target in the build audit as the default target, use it when you know that the build system creates a single executable for instance"
    print "  -a : use all build targets the build audit as the default targets, use it when you know that all built executable need to be optimized"
    print "  -q : quiet output"
    print "  -v : output version string"
    print "  -h : print this help screen"


def version():
    print os.path.basename(sys.argv[0]) + " version " + VERSION

try:
    opts, args = getopt.getopt(sys.argv[1:], "hvqC:o:i:al")
except getopt.GetoptError, err:
        print >> sys.stderr, str(err)
        sys.exit(1)

input_name = None
output_name = None
targets = None
quiet = 0
for o, a in opts:
    if o == "-C":
        configuration_path = a
    if o == "-o":
        output_name = a
    if o == "-i":
        input_name = a
    if o == "-a":
        targets = "all"
    if o == "-l":
        targets = "last"
    elif o == "q":
        quiet = 1
    elif o == "-h":
        usage()
        sys.exit()
    elif o == "-v":
        version()
        sys.exit()

if input_name == None:
    input_name = os.path.join(configuration_path, "build.audit")
if output_name == None:
    output_name = os.path.join(configuration_path, "build.mk")

if len(args) == 0:
    if targets == None:
        raise Exception("Missing target file list.")
else:
    targets = args

if quiet != 1:
    print "Computing build dependencies..."

factory = CommandDependencyListFactory(CCDEPSParser(open(input_name)), SimpleCmdInterpreter())
factory.build_dependencies()
dependencies = factory.get_dependencies()
builder = DependencyGraphBuilder(dependencies, targets)
builder.build_graph()
graph = builder.get_graph()
#print str(dependencies)
#print str(graph.graph())
#print str(graph.node_attributes())
#dot = graph.get_dot()
#gvv = gv.readstring(dot)
#gv.layout(gvv,'dot')
#gv.render(gvv,'png', target + '.graph.png')
graph.output_makefile(output_name)

# For now only write targets if configuration dir is there
skip=False
try:
    f = open(os.path.join(configuration_path, "targets"), "w")
except Exception:
    skip=True
if not skip:
    f.write("\n".join(graph.get_targets()) + "\n")
    f.close()
