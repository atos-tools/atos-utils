#!/usr/bin/env python
#
# Copyright (C) STMicroelectronics Ltd. 2012
#
# This file is part of ATOS.
#
# ATOS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License v2.0
# as published by the Free Software Foundation
#
# ATOS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# v2.0 along with ATOS. If not, see <http://www.gnu.org/licenses/>.
#
# Usage: get usage with atos-deps -h
#

VERSION="@VERSION@"

import re
import os
import sys
from pygraph.classes.digraph import digraph
from pygraph.readwrite.dot import write
from sets import Set
import gv

VERBOSE=0

class DependencyGraph:
    """ A class implementing a dependency graph. """
    def __init__(self, dg = None):
        """ Constrcutor. Optionally pass a pygraph.classes.digraph as argument.  """
        global VERBOSE
        self.dg = dg
        if self.dg == None:
            self.dg = digraph()
        self.verbose = VERBOSE

    def add_node(self, node, attrs = None):
        """ Add a node. """
        if self.verbose:
            print "ADD_NODE: " + node
        self.dg.add_node(node, attrs = attrs)

    def add_edge(self, src, dst):
        """ Add an edge. """
        if self.verbose:
            print "ADD_EDGE: " + src + " " + dst
        self.dg.add_edge((src, dst))

    def graph(self):
        """ Get the graph as a nodes, edges map. """
        return { 'nodes': self.dg.nodes(), 'edges': self.dg.edges() }

    def node_attributes(self):
        """ Get the node attributes. """
        return self.dg.node_attr

    def get_dot(self):
        """ Get a dot grapth string to be used with graphviz. """
        return write(self.dg)
        
    def get_makedep(self):
        """ Get a makefile like output. """
        mk = ""
        for node in self.dg.nodes():
            mk = mk + node + ": " + " ".join(self.dg.neighbors(node)) + "\n"
        return mk

    def get_targets(self):
        """ Get the list of targets. """
        targets = []
        for node in self.dg.neighbors("ROOT"):
            for attr,value in self.dg.node_attr[node]:
                if attr == "target":
                    targets.append(value)
        return targets

    def output_makefile(self,makefile):
        """ Get a parallelizable makefile for rebuilding the target. """
        mkfile = open(makefile,"w")
        mkfile.write("#!/usr/bin/make -f\n")
        mkfile.write("SHELL=/bin/sh\n")
        mkfile.write("FORCE=FORCE\n")
        mkfile.write("QUIET=@\n")
        mkfile.write(".PHONY: ROOT all\n")
        mkfile.write("all: ROOT\n")
        mkfile.write("FORCE:\n")
        for node in self.dg.nodes():
            target = node
            recipe = None
            for attr,value in self.dg.node_attr[node]:
                if attr == "target":
                    target = value
                if attr == "dependency":
                    if value['kind'] == "CC":
                        append=" $(ACFLAGS)"
                    if value['kind'] == "CCLD":
                        append=" $(ACFLAGS) $(ALDFLAGS)"
                    # TODO: handle quotes in command
                    recipe = "$(QUIET)cd " + value['command']['cwd'] + " && " + " ".join(value['command']['args']) + append
            deps = []
            for dep in self.dg.neighbors(node):
                for attr,value in self.dg.node_attr[dep]:
                    if attr == "target":
                        deps.append(value)
            mkfile.write(target + ": $(FORCE) " + " ".join(deps) + "\n")
            if recipe == None:
                mkfile.write("\n")
            else:
                mkfile.write("\t" + recipe + "\n")
        mkfile.close

class DependencyGraphBuilder:
    """ Class for building dependency list. """
    def __init__(self, deplist, targets):
        """ Constructor. Takes a DependencyList as argument and a list of output_file targets. """
        self.graph = DependencyGraph()
        self.deplist = deplist
        self.targets = targets

    def target_match(self, target, output):
        """ Check if output matches a target. Assume that target is a suffix of output. """
        m = re.search(os.path.normpath(target) + "$", output)
        return m != None

    def build_graph(self):
        """ Builds Add a dependency consisting of a node and input/output lists. """
        self.graph.add_node("ROOT")
        unmatched_targets = Set(self.targets)
        available_inputs = {}

        for i in range(len(self.deplist)):
            dependency = self.deplist[len(self.deplist)-i-1]
            if len(dependency['outputs']) != 1:
                continue
            output = dependency['outputs'][0]
            found = False
            for target in unmatched_targets:
                if self.target_match(target, output):
                    found = True
                    self.graph.add_node(output, attrs = [('target', output), ('dependency', dependency)])
                    self.graph.add_edge("ROOT", output)
                    for inp in dependency['inputs']:
                        available_inputs[inp] = output
            if found:
                unmatched_targets.remove(target)
            else:
                if output in available_inputs:
                    edge_src = available_inputs[output]
                    available_inputs.pop(output)
                    edge_dst = output
                    self.graph.add_node(edge_dst, attrs = [('target', output), ('dependency', dependency)])
                    self.graph.add_edge(edge_src, edge_dst)
                    for inp in dependency['inputs']:
                        available_inputs[inp] = edge_dst
            
        # Check for unmatched targets
        if len(unmatched_targets) > 0:
            raise Exception("Unmatched target in dependency graph: " + str(unmatched_targets))

    def get_graph(self):
        """ Returns the dependency graph. """
        return self.graph

class DependencyListBuilder:
    """ Class for building dependency list. """
    def __init__(self):
        """ Constructor. """
        self.deps = []

    def add_dependency(self, command, kind, inputs, outputs):
        """ Add a dependency consisting of a node and input/output lists. """
        dependency = { 'command': command, 'kind': kind, 'inputs': inputs, 'outputs': outputs }
        self.deps.append(dependency)

    def get_dependencies(self):
        """ Returns the dependency list. """
        return self.deps

class SimpleCmdInterpreter:
    """ Returns information on a command line for compilations tools. """
    def __init__(self):
        """ Constructor. """

    def select_interpreter(self, command):
        """ Returns a suitable interpreter for the given command. """
        basename = os.path.basename(command['args'][0])
        # TODO: put these regexps in a configuration file
        m = re.search("^(gcc|g\+\+|cc|c\+\+)$", basename)
        if m != None and m.group(1) != None:
            return SimpleCCInterpreter(command)
        m = re.search("^(ar)$", basename)
        if m != None and m.group(1) != None:
            return SimpleARInterpreter(command)
        raise Exception("unrecognized command: " + basename)

    def get_kind(self, command):
        """ Get command kind from command line args. """
        return self.select_interpreter(command).get_kind(command)
        
    def get_input_files(self, command):
        """ Get input files from command line args. """
        return self.select_interpreter(command).get_input_files(command)

    def get_output_files(self, command):
        """ Get output files from command line args. """
        return self.select_interpreter(command).get_output_files(command)

class SimpleCCInterpreter:
    """ Returns information on a command line for a CC compiler driver.
    There are a number of limitations:
    - only well known extensions are searched for input files
    - output file is matched only in case of -o option, no stdout support
    """
    def __init__(self, command):
        """ Constructor. """
        self.command = command

    def get_kind(self, command):
        """ Returns the command kind. """
        args = command['args']
        kind = "CCLD"
        for i in range(len(args[1:])):
            m = re.search("^(-c)$", args[i+1])
            if m != None:
                kind = "CC"
        return kind

    def get_input_files(self, command):
        """ Get input files from CC command line args (C/C++ sources or object files). """
        inputs = []
        args = command['args']
        for i in range(len(args[1:])):
            m = re.search("\\.(c|cc|cxx|cpp|c\+\+|C|i|ii|o|a)$", args[i+1])
            if m != None and m.group(1) != None and (i == 0 or args[i] != "-o"):
                    inputs.append(os.path.normpath(os.path.join(command['cwd'], args[i+1])))
        return inputs

    def get_output_files(self, command):
        """ Get output files from CC command line args. """
        args = command['args']
        outputs = []
        for i in range(len(args[1:])):
            if args[i+1] == "-o" and i+2 < len(args):
                outputs = [ os.path.normpath(os.path.join(command['cwd'], args[i+2])) ]
            else:
                m = re.search("^-o(.+)$", args[i+1])
                if m != None and m.group(1) != None:
                    outputs = [ os.path.normpath(os.path.join(command['cwd'], m.group(1))) ]
        return outputs


class SimpleARInterpreter:
    """ Returns information on a command line for a AR archiver. 
    There qre q number of limitations:
    - only .o files are searched for input
    - only 'ar ...r... input_files...' form is recognized 
    """
    def __init__(self, command):
        """ Constructor. """
        self.command = command

    def get_kind(self, command):
        """ Returns the command kind. """
        return "AR"

    def get_input_files(self, command):
        """ Get input files from AR command line (object files only). """
        inputs = []
        args = command['args']
        for i in range(len(args[1:])):
            m = re.search("\\.(o)$", args[i+1])
            if m != None and m.group(1) != None and i >= 2:
                    inputs.append(os.path.normpath(os.path.join(command['cwd'], args[i+1])))
        return inputs

    def get_output_files(self, command):
        """ Get output file from AR command line args. """
        args = command['args']
        outputs = []
        update = False
        for i in range(len(args[1:])):
            if i == 0:
                m = re.search("r", args[i+1])
                if m != None:
                    update = True
            elif i == 1 and update:
                outputs = [ os.path.normpath(os.path.join(command['cwd'], args[i+1])) ]
            else:
                break
        return outputs

class CommandDependencyListFactory:
    """ Creates a build dependency from a command parser and a command interpreter. """
    def __init__(self, parser, interpreter):
        """ Constructor. """
        self.deps = DependencyListBuilder()
        self.parser = parser
        self.interpreter = interpreter

    def get_dependencies(self):
        """ Returns the build dependencies. """
        return self.deps.get_dependencies()
    
    def build_dependencies(self):
        """ Compute dependencies.  """
        self.parser.parse()
        commands = self.parser.get_commands()
        for command in commands:
            input_files = self.interpreter.get_input_files(command)
            output_files = self.interpreter.get_output_files(command)
            kind = self.interpreter.get_kind(command)
            self.deps.add_dependency(command, kind, input_files, output_files)
                
class CCDEPSParser:
    """ Parses the output of a cc_deps addon file. """
    def __init__(self, input_file):
        """ Constructor, takes the input_file as argument. """
        self.input_file = input_file
        self.commands = []
        
    def parse(self):
        """ Parses the input_file. """
        for line in self.input_file:
            self.commands.append(self.parse_line(line))

    def parse_line(self, line):
        """ Parses a single input_file. """
        try:
            m = re.search("^CC_DEPS: \"([^\"]*)\": (.*): : \"([^\"]*)\"$", line)
            arg0 = m.group(1)
            args = m.group(2)
            cwd = m.group(3)
            len(arg0)
            len(args)
            len(cwd)
        except Exception:
            raise Exception("unexpected cc_deps command line: " + line)
        arg_list = args.split(", ")
        command = {'arg0': arg0, 'args': [], 'cwd': cwd}
        for arg in arg_list:
            try:
                m = re.search("^\"(.*)\"$", arg)
                opt = m.group(1)
                len(opt)
            except Exception:
                raise Exception("unexpected argument in command: " + arg)
            command['args'].append(opt)
        if len(command['args']) == 0:
            raise Exception("unexpected empty command: " + str(arg_list))
        return command

    def get_commands(self):
        """ Returns the constructed command list.  """
        return self.commands

if len(sys.argv) >= 2:
    target = sys.argv[1]
    input_name = "./atos-configurations/build.audit"
    if len(sys.argv) >= 3:
        input_name = sys.argv[2]
    output_name = "./atos-configurations/build.mk"
    if len(sys.argv) >= 4:
        output_name = sys.argv[3]
else:
    raise Exception("Missing input file.")

factory = CommandDependencyListFactory(CCDEPSParser(open(input_name)), SimpleCmdInterpreter())
factory.build_dependencies()
dependencies = factory.get_dependencies()
builder = DependencyGraphBuilder(dependencies, [ target ])
builder.build_graph()
graph = builder.get_graph()
#print str(dependencies)
#print str(graph.graph())
#print str(graph.node_attributes())
#dot = graph.get_dot()
#gvv = gv.readstring(dot)
#gv.layout(gvv,'dot')
#gv.render(gvv,'png', target + '.graph.png')
graph.output_makefile(output_name)

# For now only write targets if configuration dir is there
skip=False
try:
    f = open("atos-configurations/targets", "w")
except Exception:
    skip=True
if not skip:
    f.write("\n".join(graph.get_targets()) + "\n")
    f.close()
