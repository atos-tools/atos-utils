#!/usr/bin/env python
#
# Copyright (C) STMicroelectronics Ltd. 2012
#
# This file is part of ATOS.
#
# ATOS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License v2.0
# as published by the Free Software Foundation
#
# ATOS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# v2.0 along with ATOS. If not, see <http://www.gnu.org/licenses/>.
#
# Usage: get usage with atos-graph -h
#

VERSION="@VERSION@"

import re, itertools, math, threading, atexit

class optcase():

    def __init__(self, runtime, binsize, variant_id=None, flags=None, local_id=None):
        self.runtime = float(runtime)
        self.binsize = int(binsize)
        self.variant_id = variant_id
        self.flags = flags
        self.local_id = local_id

    def compute_speedup(self, ref):
        self.speedup = ((ref.runtime / self.runtime) - 1.0)
        self.sizered = (1.0 - (float(self.binsize) / float(ref.binsize)))

    def printpoint(self):
        print '-' * 40
        print self.tostring()

    def tostring(self, short=False, no_id=False):
        res = ''
        if self.local_id:
            res += 'local_id=%s\n' % (self.local_id)
        res += 'speedup=%.2f%% runtime=%.2f\n' % (self.speedup * 100, self.runtime)
        res += 'reduction=%.2f%% binsize=%d' % (self.sizered * 100, self.binsize)
        if not no_id:
            if short and len(self.variant_id) >= 45:
                legend_id = self.variant_id[:25] + '...' + self.variant_id[-15:]
            else: legend_id = self.variant_id
            res += '\nid=' + legend_id
        return res

def average(l):
    return sum(l) / len(l)

def geometric_mean(l):
    return (10 ** (sum(map(math.log10, l)) / len(l)))

class optspace():

    def __init__(self):
        self.allcases = {} # { target : { variant : [ optcase ] } }
        self.refid = None # variant used as reference for speedups
        self.targets = []
        self.cases = {} # { target : { variant : optcase } }

    # groups: 'g1:b1+b2+b3,g2=b1+b4,g3=g2+b1'
    def add_groups(self, groups):
        if groups == None: return
        groups = groups.split(',')
        # done after merging / before speedups
        for group in groups:
            name, targlist = group.split(':')
            targlist = targlist.split('+')
            common_variants = set(self.cases[targlist[0]].keys())
            for target in targlist[1:]:
                common_variants = common_variants.intersection(
                    self.cases[target].keys())
            for v in common_variants:
                time = geometric_mean(
                    [self.cases[t][v].runtime for t in targlist])
                size = sum(
                    [self.cases[t][v].binsize for t in targlist])
                newcase = optcase(
                    time, size, v, self.cases[targlist[0]][v].flags,
                    # local_id of 1st target
                    self.cases[targlist[0]][v].local_id)
                self.allcases.setdefault(
                    name, {}).setdefault(v, []).append(newcase)
                self.cases.setdefault(name, {})[v] = newcase
                if name not in self.targets: self.targets += [name]

    def compute_speedups(self, refid='REF'):
        self.refid = refid
        for target in self.targets:
            allcases = set()
            # speedup and codesize
            for (variant, optcase) in self.cases[target].items():
                optcase.compute_speedup(self.cases[target][self.refid])
                allcases.add(optcase)
            # compute frontier
            maybe_on_frontier, mustbe_on_frontier = allcases, set()
            for (variant, c) in self.cases[target].items():
                onfrontier = True
                maybe_on_frontier.remove(c)
                for c2 in itertools.chain(mustbe_on_frontier, maybe_on_frontier):
                    if c2.speedup == c.speedup and c2.sizered == c.sizered:
                        pass
                    elif c2.speedup >= c.speedup and c2.sizered >= c.sizered:
                        onfrontier = False
                        break
                if onfrontier: mustbe_on_frontier.add(c)
                c.onfront = onfrontier
            # filter - keep simplest points (smallest variant_id for now)
            front = {}
            for c in mustbe_on_frontier:
                front.setdefault((c.speedup, c.sizered), []).append(c)
            for pts in front.values():
                simplest = sorted([(len(c.variant_id), c) for c in pts])[0][1]
                for p in pts: p.onfront = (p == simplest)

    def mergeruns(self):
        self.cases = {}
        for target in self.targets:
            for (variant, optcases) in self.allcases[target].items():
                rt = [ c.runtime for c in optcases ]
                nc = optcase(sum(rt) / len(rt),
                        optcases[0].binsize, optcases[0].variant_id,
                        optcases[0].flags, optcases[0].local_id)
                self.cases.setdefault(target, {})[variant] = nc

    def read_atos_db(self, filename, filter=None):
        # ATOS: 401.bzip2: REF: version: 22028858
        # ATOS: 401.bzip2: REF: conf: -O2 -inline
        # ATOS: 401.bzip2: REF: size: 63005
        # ATOS: 401.bzip2: REF: time: 12760
        # read all optimization cases
        local_id = 0
        size, time, flags = None, None, None
        self.filter_re = filter
        for line in open(filename):
            words = sum([w.split() for w in line.strip().split(':')], [])
            (target, variant_id, key), values = words[1:4], words[4:]
            filtered = (self.filter_re and not re.search(self.filter_re, variant_id))
            if key == 'conf': flags = values
            elif key == 'size': size = values[0]
            elif key == 'time': time = values[0]
            else: continue
            if size and time:
                if 'FAILURE' not in [size, time] and not filtered:
                    newcase = optcase(time, size, variant_id, flags, local_id)
                    self.allcases.setdefault(
                        target, {}).setdefault(variant_id, []).append(newcase)
                    if target not in self.targets: self.targets += [target]
                size, time, flags = None, None, None
                local_id += 1
        self.mergeruns()
        self.db_filename = filename
        self.last_local_id = local_id
        return self

    def printfrontier(self, target=None):
        if not target: target = self.targets[-1]
        optcases = self.cases[target].values()
        frontier = [c for c in optcases if c.onfront]
        optcf = reversed(sorted([ (c.speedup, c) for c in frontier]))
        for (s, c) in optcf: c.printpoint()
        print '-' * 40
        print '%d points, %d on frontier' % (len(optcases), len(frontier))

    def get_frontier(self, target=None):
        # return frontier points, biggest speedups first
        target = target or self.targets[-1]
        optcases = self.cases[target].values()
        frontier = [(c.speedup, c) for c in optcases if c.onfront]
        frontier = reversed(sorted(frontier))
        return [x[1] for x in frontier]

    def get_point(self, ptid, target=None):
        # return the last point that match
        target = target or self.targets[-1]
        optlists = self.allcases[target].values()
        for optcases in reversed(optlists):
            optcase = optcases[-1]
            if ptid == str(optcase.local_id) or ptid == optcase.variant_id:
                return optcase
        return None


class repeattimer():

    allth = []

    def __init__(self, func, pause=1.0):
        self.func = func
        self.pause = pause
        self.ev = threading.Event()
        self.th = threading.Thread(target=self.update)
        self.th.daemon = True
        repeattimer.allth += [self]

    def update(self):
        while True:
            self.ev.wait(self.pause)
            if self.ev.isSet(): break
            self.func()

    def start(self):
        self.th.start()
        return self

    def stop(self):
        self.ev.set()

    @staticmethod
    @atexit.register
    def stopall():
        for th in repeattimer.allth: th.stop()


# ####################################################################


def draw_graph(getgraph, title, opts):
    # http://matplotlib.sourceforge.net/index.html
    import pylab as pl
    fg = pl.figure()
    ax = fg.add_subplot(111)

    global graph_plots, all_points
    graph_plots, all_points = [], []

    def draw_all():
        global graph_plots, all_points, selected_points, similar_points # :(

        # remove old plots
        old_points = [(p.sizered, p.speedup, p.local_id) for p in all_points]
        for x in list(graph_plots): graph_plots.remove(x); x.remove()

        # get graph values
        scatters, frontiers = getgraph()
        all_points = sum([x[0] for x in scatters + frontiers], [])

        # draw scatters
        for (points, attrs) in scatters:
            attrsmap = {
                's' : 20, 'label' : '_nolegend_', 'zorder' : 2,
                'color' : 'r', 'edgecolor' : 'k' }
            attrsmap.update(attrs)
            xy = zip(*[(p.sizered, p.speedup) for p in points])
            gr = ax.scatter(*xy, **attrsmap)
            graph_plots.append(gr)

        # draw frontiers (line plots)
        for (points, attrs) in frontiers:
            attrsmap = {
                'color' : 'r', 'marker' : 'o', 'label' : '_nolegend_', 'zorder' : 2,
                'markersize' : 7, 'linestyle' : 'dashed',  'linewidth' : 2 }
            attrsmap.update(attrs)
            xy = zip(*sorted([(p.sizered, p.speedup) for p in points]))
            gr, = ax.plot(xy[0], xy[1], **attrsmap)
            graph_plots.append(gr)

        # draw selected points (hidden)
        if opts.show:
            # workaround pb with pick_event event ind (4000)
            attrsmap = {
                'color'  : 'b', 'marker': 'o', 'markersize' : 20, 'linewidth' : 0,
                'alpha' : 0.4 }
            xy = zip(*sorted([(p.sizered, p.speedup) for p in all_points]))
            selected_points, = \
                ax.plot(xy[0], xy[1], visible=False, picker=4000, **attrsmap)
            graph_plots.append(selected_points)
            # similar point plot
            attrsmap.update({'color' : 'g'})
            similar_points, = ax.plot(None, None, visible=False, **attrsmap)
            graph_plots.append(selected_points)

        # highlight new points
        if opts.follow and old_points:
            new_points = [p for p in all_points if (
                    (p.sizered, p.speedup, p.local_id) not in old_points)]
            attrsmap = {
                'color'  : 'r', 'marker': 'o', 'markersize' : 20, 'linewidth' : 0,
                'alpha' : 0.4, 'zorder' : 1 }
            if new_points:
                xy = zip(*[ (p.sizered, p.speedup) for p in new_points])
                new_points, = ax.plot(*xy, **attrsmap)
                graph_plots.append(new_points)

        # redraw legend and figure
        ax.legend(loc='lower left')
        fg.canvas.draw()

    # dynamic annotations
    def on_pick(event):
        def closest(x, y):
            dp = [(math.hypot(p.sizered - x, p.speedup - y), p) for p in all_points]
            return sorted(dp)[0][1]
        def highlight(p):
            # print point on console
            p.printpoint()
            # highlight point
            selected_points.set_visible(True)
            selected_points.set_data(p.sizered, p.speedup)
            # highlight similar points (same variant_id)
            sim = zip(*([(c.sizered, c.speedup) for c in all_points
                         if c.variant_id == p.variant_id and c != p]))
            similar_points.set_visible(True)
            similar_points.set_data(sim and sim[0], sim and sim[1])
            # selected point legend
            main_legend = ax.legend_
            lg = p.tostring(short=True, no_id=opts.anonymous)
            lp = pl.legend([selected_points], [lg], loc='lower right', numpoints=1)
            pl.setp(lp.get_texts(), fontsize='medium')
            lp.get_frame().set_alpha(0.5)
            pl.gca().add_artist(main_legend)
            fg.canvas.draw()
            ax.legend_ = main_legend
        highlight(closest(event.mouseevent.xdata, event.mouseevent.ydata))

    # live plotting
    def on_timer():
        draw_all()

    # draw graph for the first time
    draw_all()

    # redraw axis, set labels, legend, grid, ...
    def labelfmt(x, pos=0): return '%.2f%%' % (100.0 * x)
    ax.xaxis.set_major_formatter(pl.FuncFormatter(labelfmt))
    ax.yaxis.set_major_formatter(pl.FuncFormatter(labelfmt))
    pl.axhspan(0.0, 0.0)
    pl.axvspan(0.0, 0.0)
    pl.title(title)
    pl.xlabel('size reduction (higher is better) -->')
    pl.ylabel('speedup (higher is better) -->')
    pl.grid(True)

    if opts.outfile:
        fg.savefig(opts.outfile)

    if opts.show:
        fg.canvas.mpl_connect('pick_event', on_pick)
        if opts.follow: repeatth = repeattimer(on_timer, 5.0).start()
        pl.show()
        if opts.follow: repeatth.stop()



# ####################################################################


def getoptcases(dbfile, opts):
    sp = optspace().read_atos_db(dbfile, opts.filter)
    sp.add_groups(opts.groups)
    sp.compute_speedups(opts.refid)
    opts.execname = opts.execname or sp.targets[-1]
    optcases = sp.cases[opts.execname].values()
    frontier = [c for c in optcases if c.onfront]
    print '%s: %d points, %d on frontier' % (
        dbfile, len(optcases), len(frontier))
    return optcases


def optgraph(dbfile, opts):

    optcases = getoptcases(dbfile, opts)

    scatters, frontiers = [], []

    # scatters definition
    scatters_def = []
    if opts.highlight:
        scatters_def += [
            (opts.highlight, {
                    's' : 40, 'color' : 'y', 'label' : 'ref cases', 'zorder' : 4})
            ]
    if opts.xd == 0:
        scatters_def += [
            ('.*', {'label' : 'opt cases', 'color' : 'b'})
            ]
    elif opts.xd == 1:
        scatters_def += [
            ('OPT(-fprofile-use)?-Os.*$', {'label' : '[-Os]', 'color' : 'green'}),
            ('OPT(-fprofile-use)?-O1.*$', {'label' : '[-O1]', 'color' : 'cyan'}),
            ('OPT(-fprofile-use)?-O2.*$', {'label' : '[-O2]', 'color' : 'blue'}),
            ('OPT(-fprofile-use)?-O3.*$', {'label' : '[-O3]', 'color' : 'red'}),
            ('.*', {'label' : '_nolegend_', 'color' : 'white'})
            ]
    elif opts.xd == 2:
        scatters_def += [
            ('OPT-fprofile-use.*-flto$', {'label' : '[fdo+lto]', 'color' : 'red'}),
            ('OPT-fprofile-use.*$', {'label' : '[fdo]', 'color' : 'blue'}),
            ('.*-flto$', {'label' : '[lto]', 'color' : 'green'}),
            ('.*', {'label' : '_nolegend_', 'color' : 'white'})
            ]
    elif opts.xd == 3:
        scatters_def += [
            ('OPT-fprofile-use-O3.*-flto$', {'label' : '[O3 fdo+lto]', 'color' : 'red'}),
            ('OPT-fprofile-use-O2.*-flto$', {'label' : '[O2 fdo+lto]', 'color' : 'green'}),
            ('OPT-fprofile-use-O3.*$', {'label' : '[O3 fdo]', 'color' : 'blue'}),
            ('OPT-fprofile-use-O2.*$', {'label' : '[O2 fdo]', 'color' : 'cyan'}),
            ('.*', {'label' : '_nolegend_', 'color' : 'white'})
            ]

    # scatters list
    if not opts.frontier_only:
        # partionning of points into scatters
        partitions, attrs_values = {}, dict(scatters_def)
        for c in optcases:
            for (opt, val) in scatters_def:
                if not re.match(opt, c.variant_id): continue
                partitions.setdefault(opt, []).append(c)
                break
        partkeys = [x[0] for x in scatters_def if x[0] in partitions.keys()]
        for opt in partkeys:
            scatters += [(partitions[opt], attrs_values[opt])]

    # frontiers list
    attrs = { 'label' : 'frontier' }
    if opts.xd != 0:
        attrs = {'marker' : 'x', 'zorder' : 1, 'mew' : 2,
                 'markersize' : 9, 'label' : '_nolegend_'}
    frontiers += [([c for c in optcases if c.onfront], attrs)]

    return scatters, frontiers


def multgraph(dbfiles, opts):

    nbdb = len(dbfiles)
    optcasesl = [getoptcases(f, opts) for f in dbfiles]

    scatters, frontiers = [], []

    # dbfiles labels and colors
    labels = [str(x) for x in range(nbdb)]
    if opts.labels: labels = opts.labels.split(',')
    colors = ['red', 'blue', 'green', 'magenta']

    # scatters list
    if not opts.frontier_only:
        for i in range(nbdb):
            attrs = {'color' : colors[i], 'label' : labels[i]}
            scatters += [(optcasesl[i], attrs)]

    # frontiers
    attrs = {'marker' : 'x', 'zorder' : 1, 'mew' : 2}
    for i in range(nbdb):
        attrs.update({'color' : colors[i]})
        if opts.frontier_only: attrs.update({'label' : 'frontier-' + labels[i]})
        frontiers += [([c for c in optcasesl[i] if c.onfront], dict(attrs))]

    return scatters, frontiers


# ####################################################################


if __name__ == "__main__":

    import optparse, os
    parser = optparse.OptionParser(
        description='Process optimization space exploration results',
        usage='%prog [options] [file]',
        version="atos-graph version " + VERSION)
    # general graph options
    parser.add_option('-o', '--outfile', dest='outfile',
                      action='store', type='string', default=None,
                      help='set the output file name (default: None)')
    parser.add_option('-d', '--hide', dest='show',
                      action='store_false', default=True,
                      help='do not show resulting graph (default: False)')
    parser.add_option('-i', '--app_id', dest='identifier',
                      action='store', type='string', default=None,
                      help='set the application identifier (default: inferred from executable)')
    parser.add_option('--follow', dest='follow',
                      action='store_true', default=False,
                      help='continuously update graph with new results (default: False)')
    # optimization space graph options
    parser.add_option('-H', dest='highlight',
                      action='store', type='string', default=None,
                      help='highlight points givena regexp')
    parser.add_option('-F', dest='frontier_only',
                      action='store_true', default=False,
                      help='display frontier only')
    parser.add_option('-x', dest='xd',
                      action='store', type='int', default=0,
                      help='highlight different options sets -x[0123]')
    parser.add_option('-a', dest='anonymous',
                      action='store_true', default=False,
                      help='anonymous configuration, omit configuration id on graph')
    parser.add_option('-l', '--cfglbl', dest='labels',
                      action='store', type='string', default='',
                      help='atos-configurations labels')
    # atos options
    parser.add_option('-e', '--exec', dest='execname',
                  action='store', type='string', default=None,
                      help='set the executable name (default: None)')
    parser.add_option('-r', '--refid', dest='refid',
                      action='store', type='string', default='REF',
                      help='set the atos reference run id (default: REF)')
    parser.add_option('-f', dest='filter',
                      action='store', type='string', default=None,
                      help='filter out the points given by the regexp')
    parser.add_option('-g', '--groups', dest='groups',
                      action='store', type='string', default=None,
                      help='add groups of targets (ex: g1:t1+t2,g2:t3) (default: None)')
    parser.add_option('-C', dest='configuration_path',
                      action='store', type='string', default="./atos-configurations",
                      help='set configuration path (default: ./atos-configurations)')
    parser.add_option('-D', dest='configuration_path_2',
                      action='append', type='string', default=[],
                      help='set additional configuration path for frontier graph (default: None)')

    (opts, args) = parser.parse_args()

    #
    dbfile = (args[0] if len(args) >= 1
              else os.path.join(opts.configuration_path, "results.db"))

    dbfiles = []
    for configuration_path in opts.configuration_path_2:
        dbfiles.append(os.path.join(configuration_path, "results.db"))

    # graph title
    title = 'Optimization Space for %s' % (opts.identifier or opts.execname)
    if opts.refid: title += ' [ref=%s]' % opts.refid
    if opts.filter: title += ' [filter=%s]' % opts.filter

    if dbfiles:
        # frontier graph
        get_graph_f = (lambda: multgraph([dbfile] + dbfiles, opts))

    else:
        # classic optimization space graph
        get_graph_f = (lambda: optgraph(dbfile, opts))

    draw_graph(get_graph_f, title=title, opts=opts)



