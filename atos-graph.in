#!/usr/bin/env python
#
# Copyright (C) STMicroelectronics Ltd. 2012
#
# This file is part of ATOS.
#
# ATOS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License v2.0
# as published by the Free Software Foundation
#
# ATOS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# v2.0 along with ATOS. If not, see <http://www.gnu.org/licenses/>.
#
# Usage: get usage with atos-graph -h
#

VERSION="@VERSION@"

import re, itertools, math

class optcase():

    def __init__(self, runtime, binsize, variant_id=None, flags=None, local_id=None):
        self.runtime = float(runtime)
        self.binsize = int(binsize)
        self.variant_id = variant_id
        self.flags = flags
        self.local_id = local_id

    def compute_speedup(self, ref):
        self.speedup = ((ref.runtime / self.runtime) - 1.0)
        self.sizered = (1.0 - (float(self.binsize) / float(ref.binsize)))

    def printpoint(self):
        print '-' * 40
        if self.local_id != None:
            print 'local_id: %s' % self.local_id
        print 'id: %s' % self.variant_id
        print '\tspeedup: %.2f%% runtime: %f' % (self.speedup * 100.0, self.runtime)
        print '\treduction: %.2f%% binsize: %d' % (self.sizered * 100.0, self.binsize)
        print '\tflags: %s' % " ".join(self.flags)

def average(l):
    return sum(l) / len(l)

def geometric_mean(l):
    # does not wotk on big numbers (long int too large to convert to float)
    # print l, (10 ** (sum(map(math.log10, l)) / len(l)))
    # return (reduce(lambda x, y: x * y, l)) ** (1.0 / len(l))
    return (10 ** (sum(map(math.log10, l)) / len(l)))

class optspace():

    def __init__(self):
        self.allcases = {} # { target : { variant : [ optcase ] } }
        self.refid = None # variant used as reference for speedups
        self.targets = []
        self.cases = {} # { target : { variant : optcase } }

    # groups: 'g1:b1+b2+b3,g2=b1+b4,g3=g2+b1'
    def add_groups(self, groups):
        if groups == None: return
        groups = groups.split(',')
        # done after merging / before speedups
        for group in groups:
            name, targlist = group.split(':')
            targlist = targlist.split('+')
            common_variants = set(self.cases[targlist[0]].keys())
            for target in targlist[1:]:
                common_variants = common_variants.intersection(
                    self.cases[target].keys())
            for v in common_variants:
                time = geometric_mean(
                    [self.cases[t][v].runtime for t in targlist])
                size = sum(
                    [self.cases[t][v].binsize for t in targlist])
                newcase = optcase(
                    time, size, v, self.cases[targlist[0]][v].flags,
                    # local_id of 1st target
                    self.cases[targlist[0]][v].local_id)
                self.allcases.setdefault(
                    name, {}).setdefault(v, []).append(newcase)
                self.cases.setdefault(name, {})[v] = newcase
                if name not in self.targets: self.targets += [name]

    def compute_speedups(self, refid='REF'):
        self.refid = refid
        for target in self.targets:
            allcases = set()
            # speedup and codesize
            for (variant, optcase) in self.cases[target].items():
                optcase.compute_speedup(self.cases[target][self.refid])
                allcases.add(optcase)
            # compute frontier
            maybe_on_frontier, mustbe_on_frontier = allcases, set()
            for (variant, c) in self.cases[target].items():
                onfrontier = True
                maybe_on_frontier.remove(c)
                for c2 in itertools.chain(mustbe_on_frontier, maybe_on_frontier):
                    if c2.speedup == c.speedup and c2.sizered == c.sizered:
                        pass
                    elif c2.speedup >= c.speedup and c2.sizered >= c.sizered:
                        onfrontier = False
                        break
                if onfrontier: mustbe_on_frontier.add(c)
                c.onfront = onfrontier
            # filter - keep simplest points (smallest variant_id for now)
            front = {}
            for c in mustbe_on_frontier:
                front.setdefault((c.speedup, c.sizered), []).append(c)
            for pts in front.values():
                simplest = sorted([(len(c.variant_id), c) for c in pts])[0][1]
                for p in pts: p.onfront = (p == simplest)

    def mergeruns(self):
        self.cases = {}
        for target in self.targets:
            for (variant, optcases) in self.allcases[target].items():
                rt = [ c.runtime for c in optcases ]
                nc = optcase(sum(rt) / len(rt),
                        optcases[0].binsize, optcases[0].variant_id,
                        optcases[0].flags, optcases[0].local_id)
                self.cases.setdefault(target, {})[variant] = nc

    def read_atos_db(self, filename, filter=None):
        # ATOS: 401.bzip2: REF: version: 22028858
        # ATOS: 401.bzip2: REF: conf: -O2 -inline
        # ATOS: 401.bzip2: REF: size: 63005
        # ATOS: 401.bzip2: REF: time: 12760
        # read all optimization cases
        local_id = 0
        size, time, flags = None, None, None
        self.filter_re = filter
        for line in open(filename):
            words = sum([w.split() for w in line.strip().split(':')], [])
            (target, variant_id, key), values = words[1:4], words[4:]
            filtered = (self.filter_re and not re.search(self.filter_re, variant_id))
            if key == 'conf': flags = values
            elif key == 'size': size = values[0]
            elif key == 'time': time = values[0]
            else: continue
            if size and time:
                if 'FAILURE' not in [size, time] and not filtered:
                    newcase = optcase(time, size, variant_id, flags, local_id)
                    self.allcases.setdefault(
                        target, {}).setdefault(variant_id, []).append(newcase)
                    if target not in self.targets: self.targets += [target]
                size, time, flags = None, None, None
                local_id += 1
        self.mergeruns()
        self.db_filename = filename
        self.last_local_id = local_id
        return self

    def update_db(self):
        # todo: read new db lines only
        old_last = self.last_local_id
        self.read_atos_db(self.db_filename, self.filter_re)
        if old_last == self.last_local_id: return False
        self.compute_speedups(self.refid)
        return True

    def graph(self, **kwargs):
        # http://matplotlib.sourceforge.net/index.html
        import pylab as pl
        # keywords arguments
        show = kwargs.get('show', False)
        outfile = kwargs.get('outfile', None)
        xd = kwargs.get('xd', 0)
        yd = kwargs.get('yd', 0)
        identifier = kwargs.get('identifier', None)
        # select target
        execname = kwargs.get('execname', None)
        if not execname: execname = self.targets[-1]
        optcases = self.cases[execname].values()
        identifier = kwargs.get('identifier', None)
        if not identifier: identifier = execname
        # higlighted points
        highcases = kwargs.get('highlight', None)
        if highcases: highcases = [
            c for c in optcases if re.search(highcases, c.variant_id)]
        # all points coordinates
        allpts = [ (c.sizered, c.speedup, c) for c in optcases ]
        #
        fg = pl.figure()
        ax = fg.add_subplot(111)
        if xd == 0: # simple graph
            # optcases not on frontier
            xy = zip(*[ (c.sizered, c.speedup) for c in optcases if not c.onfront])
            ax.scatter(*xy, s=20, c='b', label='opt cases', zorder=5,
                        visible=(not kwargs.get('frontier_only', False)))
            # optcases on frontier
            xy = zip(*sorted([ (c.sizered, c.speedup) for c in optcases if c.onfront]))
            # ax.scatter(*xy, s=20, c='r', label='frontier')
            ax.plot(xy[0], xy[1], ms=8, c='r', label='frontier',
                    marker='o', linestyle='dashed', zorder=10)
        if xd == 1: # optimization level scatter
            cols = {'': 'black', '-Os' : 'green', '-O0' : 'white',
                    '-O1' : 'cyan', '-O2' : 'blue', '-O3' : 'red'}
            for opt in cols.keys():
                xy = zip(*[ (c.sizered, c.speedup) for c in optcases
                            if c.flags and c.flags[0] == opt])
                if len(xy) == 0: continue
                lbl = '%s' % (opt and '[%s]' % opt or '_nolegend_')
                ax.scatter(*xy, s=20, c=cols[opt], marker='o',
                            label=lbl, zorder=5)
        if xd == 2: # graph with more details
            # build variant scatter
            def getv(c):
                lto = c.variant_id.find('-flto') != -1
                fdo = c.variant_id.find('-fprofile-use') != -1
                return ((lto and fdo) and 'fdo+lto'
                        or (lto and 'lto' or (fdo and 'fdo' or '')))
            cols = { '': 'white', 'fdo' : 'blue', 'lto' : 'green', 'fdo+lto' : 'red' }
            for opt in cols.keys():
                xy = zip(*[ (c.sizered, c.speedup) for c in optcases
                            if getv(c)==opt])
                if len(xy) == 0: continue
                lbl = '%s' % (opt and '[%s]' % opt or '_nolegend_')
                ax.scatter(*xy, s=20, c=cols[opt], marker='o',
                            label=lbl, zorder=5)
        if xd == 3: # graph with more details
            # build O2/O3/fdo/fdo+lto scatter
            def getv(c):
                lto = c.variant_id.find('-flto') != -1
                fdo = c.variant_id.find('-fprofile-use') != -1
                opl = ((c.flags and c.flags[0] in ['-O2', '-O3'])
                        and c.flags[0][1:] or '')
                vrt = (lto and fdo) and 'fdo+lto' or (fdo and 'fdo' or '')
                return (opl and vrt) and ('%s %s' % (opl, vrt)) or ''
            cols = { '': 'white',
                     'O2 fdo' : 'cyan', 'O2 fdo+lto' : 'green',
                     'O3 fdo' : 'blue', 'O3 fdo+lto' : 'red' }
            for opt in cols.keys():
                xy = zip(*[ (c.sizered, c.speedup) for c in optcases
                            if getv(c)==opt])
                if len(xy) == 0: continue
                lbl = '%s' % (opt and '[%s]' % opt or '_nolegend_')
                ax.scatter(*xy, s=20, c=cols[opt], marker='o',
                            label=lbl, zorder=5)
        if xd >= 1: # graph with more details
            # frontier
            xy = zip(*sorted([ (c.sizered, c.speedup) for c in optcases if c.onfront]))
            ax.plot(xy[0], xy[1], c='r', label='_nolegend_', zorder=1,
                    marker='x', markersize=9, markeredgewidth=2,
                    linewidth=2, linestyle='dashed')
        # Highlight points if requested
        if highcases:
            xy = zip(*[ (c.sizered, c.speedup) for c in highcases])
            ax.scatter(*xy, s=40, c='y', label='ref cases', zorder=20)
        # dynamic annotations
        def on_pick(event):
            def closest(x, y):
                dp = [(math.hypot(a-x,b-y),(a,b,c)) for (a,b,c) in allpts]
                return sorted(dp)[0][1]
            def basepoint(c):
                if yd == 0: return [c.sizered], [c.speedup]
                x = re.match('^(OPT)(-fprofile-use-O.)?.*?(-O.).*?(-flto)?$', c.variant_id)
                if not x: return [c.sizered], [c.speedup]
                baseid = ''.join([s for s in x.groups() if s is not None])
                basept = [ x for x in optcases if x.variant_id == baseid ]
                res = [c] + (basept and [basept[0]] or [])
                return [x.sizered for x in res], [x.speedup for x in res]
            def highlight((x, y, c)):
                # print point on console
                c.printpoint()
                # highlight point
                selected_points.set_visible(True)
                selected_points.set_data(*basepoint(c))
                # selected point legend
                sc = (len(c.variant_id) >= 45
                      and c.variant_id[:25] + '...' + c.variant_id[-15:] or c.variant_id)
                if c.local_id != None:
                    tt = 'local_id=%s\n' % (c.local_id)
                else:
                    tt = ""
                tt+= 'speedup=%.2f%% runtime=%.2f\n' % (c.speedup * 100.0, c.runtime)
                tt+= 'reduction=%.2f%% binsize=%d\n' % (c.sizered * 100.0, c.binsize)
                if not kwargs.get('anonymous', False):
                    tt+= 'id=%s' % (sc)
                lp = pl.legend([selected_points], [tt], loc='lower right', numpoints=1)
                pl.setp(lp.get_texts(), fontsize='medium')
                lp.get_frame().set_alpha(0.5)
                pl.gca().add_artist(main_legend)
                fg.canvas.draw()
            highlight(closest(event.mouseevent.xdata, event.mouseevent.ydata))
        if show:
            # workaround pb with pick_event event ind (4000)
            selected_points, = ax.plot(
                [x[0] for x in allpts], [x[1] for x in allpts],
                marker='o', ms=20, alpha=0.4, color='b', visible=False,
                picker=4000)
            fg.canvas.mpl_connect('pick_event', on_pick)
        # redraw axis, set labels, legend, grid, ...
        def labelfmt(x, pos=0): return '%.2f%%' % (100.0 * x)
        ax.xaxis.set_major_formatter(pl.FuncFormatter(labelfmt))
        ax.yaxis.set_major_formatter(pl.FuncFormatter(labelfmt))
        pl.axhspan(0.0, 0.0)
        pl.axvspan(0.0, 0.0)
        ptitle = 'Optimization Space for %s' % identifier
        if self.refid:
            ptitle += ' [ref=%s]' % self.refid
        if self.filter_re:
            ptitle += ' [filter=%s]' % self.filter_re
        pl.title(ptitle)
        pl.xlabel('size reduction (higher is better) -->')
        pl.ylabel('speedup (higher is better) -->')
        pl.grid(True)
        main_legend = ax.legend(loc='lower left')
        #
        if outfile: pl.savefig(outfile)
        if show: pl.show()

    def printfrontier(self, target=None):
        if not target: target = self.targets[-1]
        optcases = self.cases[target].values()
        frontier = [c for c in optcases if c.onfront]
        optcf = reversed(sorted([ (c.speedup, c) for c in frontier]))
        for (s, c) in optcf: c.printpoint()
        print '-' * 40
        print '%d points, %d on frontier' % (len(optcases), len(frontier))

    def get_frontier(self, target=None):
        # return frontier points, biggest speedups first
        target = target or self.targets[-1]
        optcases = self.cases[target].values()
        frontier = [(c.speedup, c) for c in optcases if c.onfront]
        frontier = reversed(sorted(frontier))
        return [x[1] for x in frontier]

    def get_point(self, ptid, target=None):
        # return the last point that match
        target = target or self.targets[-1]
        optlists = self.allcases[target].values()
        for optcases in reversed(optlists):
            optcase = optcases[-1]
            if ptid == str(optcase.local_id) or ptid == optcase.variant_id:
                return optcase
        return None


# ####################################################################


if __name__ == "__main__":

    import optparse, os
    parser = optparse.OptionParser(
        description='Process optimization space exploration results',
        usage='%prog [options] [file]',
        version="atos-graph version " + VERSION)
    #
    parser.add_option('-o', '--outfile', dest='outfile',
                      action='store', type='string', default=None,
                      help='set the output file name (default: None)')
    parser.add_option('-d', '--hide', dest='show',
                      action='store_false', default=True,
                      help='do not show resulting graph (default: False)')
    parser.add_option('-i', '--app_id', dest='identifier',
                  action='store', type='string', default=None,
                      help='set the application identifier (default: inferred from executable)')
    parser.add_option('-e', '--exec', dest='execname',
                  action='store', type='string', default=None,
                      help='set the executable name (default: None)')
    parser.add_option('-H', dest='highlight',
                      action='store', type='string', default=None,
                      help='highlight points givena regexp')
    parser.add_option('-F', dest='frontier_only',
                      action='store_true', default=False,
                      help='display frontier only')
    parser.add_option('-x', dest='xd',
                      action='store', type='int', default=0,
                      help='highlight different options sets -x[0123]')
    parser.add_option('-y', dest='yd',
                      action='store', type='int', default=0,
                      help='display base points when picking a configuration -y[01]')
    parser.add_option('-a', dest='anonymous',
                      action='store_true', default=False,
                      help='anonymous configuration, omit configuration id on graph')
    #
    parser.add_option('-r', '--refid', dest='refid',
                      action='store', type='string', default='REF',
                      help='set the atos reference run id (default: REF)')
    parser.add_option('-f', dest='filter',
                      action='store', type='string', default=None,
                      help='filter out the points given by the regexp')
    parser.add_option('-g', '--groups', dest='groups',
                      action='store', type='string', default=None,
                      help='add groups of targets (ex: g1:t1+t2,g2:t3) (default: None)')
    parser.add_option('-C', dest='configuration_path',
                      action='store', type='string', default="./atos-configurations",
                      help='set configuration path (default: ./atos-configurations)')

    (opts, args) = parser.parse_args()

    default_infilename = os.path.join(opts.configuration_path, "results.db")
    default_targets = os.path.join(opts.configuration_path, "targets")

    if len(args) == 0:
        infilename = default_infilename
    else:
        infilename = args[0]
    sp = optspace().read_atos_db(infilename, opts.filter)
    sp.add_groups(opts.groups)
    sp.compute_speedups(opts.refid)
    sp.printfrontier(opts.execname)
    sp.graph(**vars(opts))
