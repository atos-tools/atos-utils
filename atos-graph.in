#!/usr/bin/env python
#
# Copyright (C) STMicroelectronics Ltd. 2012
#
# This file is part of ATOS.
#
# ATOS is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License v2.0
# as published by the Free Software Foundation
#
# ATOS is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# v2.0 along with ATOS. If not, see <http://www.gnu.org/licenses/>.
#
# Usage: get usage with atos-graph -h
#

VERSION="@VERSION@"

import re, itertools, math

class optcase():

    def __init__(self, runtime, binsize, variant_id=None, flags=None, local_id=None):
        self.runtime = float(runtime)
        self.binsize = int(binsize)
        self.variant_id = variant_id
        self.flags = flags
        self.local_id = local_id

    def compute_speedup(self, ref):
        self.speedup = ((ref.runtime / self.runtime) - 1.0)
        self.sizered = (1.0 - (float(self.binsize) / float(ref.binsize)))

    def printpoint(self):
        print '-' * 40
        print self.tostring()

    def tostring(self, short=False, no_id=False):
        res = ''
        if self.local_id:
            res += 'local_id=%s\n' % (self.local_id)
        res += 'speedup=%.2f%% runtime=%.2f\n' % (self.speedup * 100, self.runtime)
        res += 'reduction=%.2f%% binsize=%d' % (self.sizered * 100, self.binsize)
        if not no_id:
            if short and len(self.variant_id) >= 45:
                legend_id = self.variant_id[:25] + '...' + self.variant_id[-15:]
            else: legend_id = self.variant_id
            res += '\nid=' + legend_id
        return res

def average(l):
    return sum(l) / len(l)

def geometric_mean(l):
    return (10 ** (sum(map(math.log10, l)) / len(l)))

class optspace():

    def __init__(self):
        self.allcases = {} # { target : { variant : [ optcase ] } }
        self.refid = None # variant used as reference for speedups
        self.targets = []
        self.cases = {} # { target : { variant : optcase } }

    # groups: 'g1:b1+b2+b3,g2=b1+b4,g3=g2+b1'
    def add_groups(self, groups):
        if groups == None: return
        groups = groups.split(',')
        # done after merging / before speedups
        for group in groups:
            name, targlist = group.split(':')
            targlist = targlist.split('+')
            common_variants = set(self.cases[targlist[0]].keys())
            for target in targlist[1:]:
                common_variants = common_variants.intersection(
                    self.cases[target].keys())
            for v in common_variants:
                time = geometric_mean(
                    [self.cases[t][v].runtime for t in targlist])
                size = sum(
                    [self.cases[t][v].binsize for t in targlist])
                newcase = optcase(
                    time, size, v, self.cases[targlist[0]][v].flags,
                    # local_id of 1st target
                    self.cases[targlist[0]][v].local_id)
                self.allcases.setdefault(
                    name, {}).setdefault(v, []).append(newcase)
                self.cases.setdefault(name, {})[v] = newcase
                if name not in self.targets: self.targets += [name]

    def compute_speedups(self, refid='REF'):
        self.refid = refid
        for target in self.targets:
            allcases = set()
            # speedup and codesize
            for (variant, optcase) in self.cases[target].items():
                optcase.compute_speedup(self.cases[target][self.refid])
                allcases.add(optcase)
            # compute frontier
            maybe_on_frontier, mustbe_on_frontier = allcases, set()
            for (variant, c) in self.cases[target].items():
                onfrontier = True
                maybe_on_frontier.remove(c)
                for c2 in itertools.chain(mustbe_on_frontier, maybe_on_frontier):
                    if c2.speedup == c.speedup and c2.sizered == c.sizered:
                        pass
                    elif c2.speedup >= c.speedup and c2.sizered >= c.sizered:
                        onfrontier = False
                        break
                if onfrontier: mustbe_on_frontier.add(c)
                c.onfront = onfrontier
            # filter - keep simplest points (smallest variant_id for now)
            front = {}
            for c in mustbe_on_frontier:
                front.setdefault((c.speedup, c.sizered), []).append(c)
            for pts in front.values():
                simplest = sorted([(len(c.variant_id), c) for c in pts])[0][1]
                for p in pts: p.onfront = (p == simplest)

    def mergeruns(self):
        self.cases = {}
        for target in self.targets:
            for (variant, optcases) in self.allcases[target].items():
                rt = [ c.runtime for c in optcases ]
                nc = optcase(sum(rt) / len(rt),
                        optcases[0].binsize, optcases[0].variant_id,
                        optcases[0].flags, optcases[0].local_id)
                self.cases.setdefault(target, {})[variant] = nc

    def read_atos_db(self, filename, filter=None):
        # ATOS: 401.bzip2: REF: version: 22028858
        # ATOS: 401.bzip2: REF: conf: -O2 -inline
        # ATOS: 401.bzip2: REF: size: 63005
        # ATOS: 401.bzip2: REF: time: 12760
        # read all optimization cases
        local_id = 0
        size, time, flags = None, None, None
        self.filter_re = filter
        for line in open(filename):
            words = sum([w.split() for w in line.strip().split(':')], [])
            (target, variant_id, key), values = words[1:4], words[4:]
            filtered = (self.filter_re and not re.search(self.filter_re, variant_id))
            if key == 'conf': flags = values
            elif key == 'size': size = values[0]
            elif key == 'time': time = values[0]
            else: continue
            if size and time:
                if 'FAILURE' not in [size, time] and not filtered:
                    newcase = optcase(time, size, variant_id, flags, local_id)
                    self.allcases.setdefault(
                        target, {}).setdefault(variant_id, []).append(newcase)
                    if target not in self.targets: self.targets += [target]
                size, time, flags = None, None, None
                local_id += 1
        self.mergeruns()
        self.db_filename = filename
        self.last_local_id = local_id
        return self

    def printfrontier(self, target=None):
        if not target: target = self.targets[-1]
        optcases = self.cases[target].values()
        frontier = [c for c in optcases if c.onfront]
        optcf = reversed(sorted([ (c.speedup, c) for c in frontier]))
        for (s, c) in optcf: c.printpoint()
        print '-' * 40
        print '%d points, %d on frontier' % (len(optcases), len(frontier))

    def get_frontier(self, target=None):
        # return frontier points, biggest speedups first
        target = target or self.targets[-1]
        optcases = self.cases[target].values()
        frontier = [(c.speedup, c) for c in optcases if c.onfront]
        frontier = reversed(sorted(frontier))
        return [x[1] for x in frontier]

    def get_point(self, ptid, target=None):
        # return the last point that match
        target = target or self.targets[-1]
        optlists = self.allcases[target].values()
        for optcases in reversed(optlists):
            optcase = optcases[-1]
            if ptid == str(optcase.local_id) or ptid == optcase.variant_id:
                return optcase
        return None


# ####################################################################


def draw_graph(scatters, frontiers, selectpts, title, opts):
    # http://matplotlib.sourceforge.net/index.html
    import pylab as pl
    fg = pl.figure()
    ax = fg.add_subplot(111)

    # draw scatters
    for (points, attrs) in scatters:
        attrsmap = {
            's' : 20, 'label' : '_nolegend_', 'zorder' : 2,
            'color' : 'r', 'edgecolor' : 'k' }
        attrsmap.update(attrs)
        xy = zip(*[(p.sizered, p.speedup) for p in points])
        ax.scatter(*xy, **attrsmap)

    # draw frontiers
    for (points, attrs) in frontiers:
        attrsmap = {
            'color' : 'r', 'marker' : 'o', 'label' : '_nolegend_', 'zorder' : 2,
            'markersize' : 7, 'linestyle' : 'dashed',  'linewidth' : 2 }
        attrsmap.update(attrs)
        xy = zip(*sorted([(p.sizered, p.speedup) for p in points]))
        ax.plot(xy[0], xy[1], **attrsmap)

    # dynamic annotations
    def on_pick(event):
        def closest(x, y):
            dp = [(math.hypot(a-x,b-y),(a,b,c,d)) for (a,b,c,d) in selectpts]
            return sorted(dp)[0][1]
        def highlight((x, y, l, f)):
            # callback for selected point (print point on console)
            if f: f()
            # highlight point
            selected_points.set_visible(True)
            selected_points.set_data(x, y)
            # selected point legend
            lp = pl.legend([selected_points], [l], loc='lower right', numpoints=1)
            pl.setp(lp.get_texts(), fontsize='medium')
            lp.get_frame().set_alpha(0.5)
            pl.gca().add_artist(main_legend)
            fg.canvas.draw()
        highlight(closest(event.mouseevent.xdata, event.mouseevent.ydata))

    if opts.show and selectpts:
        # workaround pb with pick_event event ind (4000)
        attrsmap = {
            'color'  : 'b', 'marker': 'o', 'markersize' : 20, 'alpha' : 0.4 }
        xy = zip(*[(x[0], x[1]) for x in selectpts])
        selected_points, = \
            ax.plot(xy[0], xy[1], visible=False, picker=4000, **attrsmap)
        fg.canvas.mpl_connect('pick_event', on_pick)

    # redraw axis, set labels, legend, grid, ...
    def labelfmt(x, pos=0): return '%.2f%%' % (100.0 * x)
    ax.xaxis.set_major_formatter(pl.FuncFormatter(labelfmt))
    ax.yaxis.set_major_formatter(pl.FuncFormatter(labelfmt))
    pl.axhspan(0.0, 0.0)
    pl.axvspan(0.0, 0.0)
    pl.title(title)
    pl.xlabel('size reduction (higher is better) -->')
    pl.ylabel('speedup (higher is better) -->')
    pl.grid(True)
    main_legend = ax.legend(loc='lower left')

    if opts.outfile: fg.savefig(opts.outfile)
    if opts.show: pl.show()


def graph(optcases, opts):

    scatters, frontiers = [], []

    # scatters definition
    scatters_def = []
    if opts.highlight:
        scatters_def += [
            (opts.highlight, {
                    's' : 40, 'color' : 'y', 'label' : 'ref cases', 'zorder' : 4})
            ]
    if opts.xd == 0:
        scatters_def += [
            ('.*', {'label' : 'opt cases', 'color' : 'b'})
            ]
    elif opts.xd == 1:
        scatters_def += [
            ('OPT(-fprofile-use)?-Os.*$', {'label' : '[-Os]', 'color' : 'green'}),
            ('OPT(-fprofile-use)?-O1.*$', {'label' : '[-O1]', 'color' : 'cyan'}),
            ('OPT(-fprofile-use)?-O2.*$', {'label' : '[-O2]', 'color' : 'blue'}),
            ('OPT(-fprofile-use)?-O3.*$', {'label' : '[-O3]', 'color' : 'red'}),
            ('.*', {'label' : '_nolegend_', 'color' : 'white'})
            ]
    elif opts.xd == 2:
        scatters_def += [
            ('OPT-fprofile-use.*-flto$', {'label' : '[fdo+lto]', 'color' : 'red'}),
            ('OPT-fprofile-use.*$', {'label' : '[fdo]', 'color' : 'blue'}),
            ('.*-flto$', {'label' : '[lto]', 'color' : 'green'}),
            ('.*', {'label' : '_nolegend_', 'color' : 'white'})
            ]
    elif opts.xd == 3:
        scatters_def += [
            ('OPT-fprofile-use-O3.*-flto$', {'label' : '[O3 fdo+lto]', 'color' : 'red'}),
            ('OPT-fprofile-use-O2.*-flto$', {'label' : '[O2 fdo+lto]', 'color' : 'green'}),
            ('OPT-fprofile-use-O3.*$', {'label' : '[O3 fdo]', 'color' : 'blue'}),
            ('OPT-fprofile-use-O2.*$', {'label' : '[O2 fdo]', 'color' : 'cyan'}),
            ('.*', {'label' : '_nolegend_', 'color' : 'white'})
            ]

    # scatters list
    if not opts.frontier_only:
        # partionning of points into scatters
        partitions, attrs_values = {}, dict(scatters_def)
        for c in optcases:
            for (opt, val) in scatters_def:
                if not re.match(opt, c.variant_id): continue
                partitions.setdefault(opt, []).append(c)
                break
        partkeys = [x[0] for x in scatters_def if x[0] in partitions.keys()]
        for opt in partkeys:
            scatters += [(partitions[opt], attrs_values[opt])]

    # frontiers list
    attrs = { 'label' : 'frontier' }
    if opts.xd != 0:
        attrs = {'marker' : 'x', 'zorder' : 1, 'mew' : 2,
                 'markersize' : 9, 'label' : '_nolegend_'}
    frontiers += [([c for c in optcases if c.onfront], attrs)]

    # point selection (coords, legend, callback)
    allpts = sum([x[0] for x in scatters + frontiers], [])
    selectpts = [
        (c.sizered, c.speedup, c.tostring(short=True, no_id=opts.anonymous),
         c.printpoint) for c in allpts]

    # graph title
    title = 'Optimization Space for %s' % (opts.identifier or opts.execname)
    if opts.refid: title += ' [ref=%s]' % opts.refid
    if opts.filter: title += ' [filter=%s]' % opts.filter

    draw_graph(
        scatters=scatters, frontiers=frontiers,
        title=title, selectpts=selectpts, opts=opts)



# ####################################################################


if __name__ == "__main__":

    import optparse, os
    parser = optparse.OptionParser(
        description='Process optimization space exploration results',
        usage='%prog [options] [file]',
        version="atos-graph version " + VERSION)
    # general graph options
    parser.add_option('-o', '--outfile', dest='outfile',
                      action='store', type='string', default=None,
                      help='set the output file name (default: None)')
    parser.add_option('-d', '--hide', dest='show',
                      action='store_false', default=True,
                      help='do not show resulting graph (default: False)')
    parser.add_option('-i', '--app_id', dest='identifier',
                      action='store', type='string', default=None,
                      help='set the application identifier (default: inferred from executable)')
    # optimization space graph options
    parser.add_option('-H', dest='highlight',
                      action='store', type='string', default=None,
                      help='highlight points givena regexp')
    parser.add_option('-F', dest='frontier_only',
                      action='store_true', default=False,
                      help='display frontier only')
    parser.add_option('-x', dest='xd',
                      action='store', type='int', default=0,
                      help='highlight different options sets -x[0123]')
    parser.add_option('-a', dest='anonymous',
                      action='store_true', default=False,
                      help='anonymous configuration, omit configuration id on graph')
    # atos options
    parser.add_option('-e', '--exec', dest='execname',
                  action='store', type='string', default=None,
                      help='set the executable name (default: None)')
    parser.add_option('-r', '--refid', dest='refid',
                      action='store', type='string', default='REF',
                      help='set the atos reference run id (default: REF)')
    parser.add_option('-f', dest='filter',
                      action='store', type='string', default=None,
                      help='filter out the points given by the regexp')
    parser.add_option('-g', '--groups', dest='groups',
                      action='store', type='string', default=None,
                      help='add groups of targets (ex: g1:t1+t2,g2:t3) (default: None)')
    parser.add_option('-C', dest='configuration_path',
                      action='store', type='string', default="./atos-configurations",
                      help='set configuration path (default: ./atos-configurations)')

    (opts, args) = parser.parse_args()

    infilename = (args[0] if len(args) >= 1
                  else os.path.join(opts.configuration_path, "results.db"))
    sp = optspace().read_atos_db(infilename, opts.filter)
    sp.add_groups(opts.groups)
    sp.compute_speedups(opts.refid)
    opts.execname = opts.execname or sp.targets[-1]

    sp.printfrontier(opts.execname)
    graph(sp.cases[opts.execname].values(), opts)
